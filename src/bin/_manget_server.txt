use std::path::PathBuf;

use axum::response::IntoResponse;
use axum::routing::get;
use axum::{Router, Json};
use manget::manga::{self, ChapterError};
use uuid::Uuid;
use serde::Deserialize;
use tower_http::trace::TraceLayer;

// #[derive(Debug, thiserror::Error)]
// enum WrapperError {
//     #[error(transparent)]
//     InnerError(#[from] ChapterError),
// }

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .init();

    let app = Router::new()
        .route("/api", get(download))
        .route("/download", get(download))
        .layer(TraceLayer::new_for_http());

    axum::Server::bind(&"0.0.0.0:8080".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn download(Json(request): Json<DownloadRequest>) -> impl IntoResponse {
    request.url
    // if let Ok((_file_name, file_path)) = download_chapter_from_url(&request.url).await {
    //     if let Ok(_file) = tokio::fs::File::open(file_path).await {
    //        StatusCode::OK;
    //     } else {
    //         StatusCode::INTERNAL_SERVER_ERROR;
    //     }
    // } else {
    //     StatusCode::INTERNAL_SERVER_ERROR;
    // }
}

#[derive(Debug, Deserialize)]
struct DownloadRequest {
    url: String,
}

async fn download_chapter_from_url(url: &str) -> Result<(String, PathBuf), ChapterError> {
    let chapter = manga::get_chapter(url).await?;
    let random_file_name = Uuid::new_v4().to_string();
    let zip_path = tempfile::tempdir()?.into_path().join(random_file_name);
    let file_path = manga::download_chapter_as_cbz(&chapter, Some(zip_path)).await?;
    let chapter_full_name = manga::generate_chapter_full_name(&chapter);
    Ok((format!("{chapter_full_name}.cbz"), file_path))
}

// impl IntoResponse for WrapperError {
//     fn into_response(self) -> axum::response::Response {
//         todo!()
//     }
// }